/*
You are provided with a skeleton of the class 'Fraction', which accepts two arguments (numerator, denominator).

EXAMPLE:

Fraction fraction1 = new Fraction(4, 5);
Your task is to make this class string representable, and addable while keeping the result in the minimum representation possible.

EXAMPLE:

System.out.println(fraction1.add(new Fraction(1, 8)));
// Outputs: 37/40
NB: DON'T use the built_in class 'fractions.Fraction'

Enjoy!
*/

public class Fraction implements Comparable<Fraction>
{
    private final long top;
    private final long bottom;

    // Constructor automatically reduces the fraction.
    public Fraction(long numerator, long denominator) {
        if (denominator == 0) {
            throw new IllegalArgumentException("Denominator cannot be zero.");
        }
        // Normalize: make the denominator positive.
        if (denominator < 0) {
            numerator = -numerator;
            denominator = -denominator;
        }
        // Reduce the fraction using the GCD.
        long gcd = gcd(Math.abs(numerator), denominator);
        this.top = numerator / gcd;
        this.bottom = denominator / gcd;
    }
    
    // Helper method: Eucledean algorithm to compute GCD.
    private static long gcd(long a, long b) {
        while (b != 0) {
            long temp = b;
            b = a % b;
            a = temp;
        }
        return a;
}        

    @Override
    public int hashCode() {
        return 17 * Long.hashCode(top) + Long.hashCode(bottom);
    }
    
    @Override
    public boolean equals(Object o) { 
        if (this == o) return true;
        if (!(o instanceof Fraction)) return false;
        return compareTo((Fraction)o) == 0;
    }    
    
    @Override
    public int compareTo(Fraction f2){
        // Cross multiply to compare fractions without converting to floating-point
        return Long.compare(top * f2.bottom, f2.top * bottom);
    }
    
    //Add two fractions
    // (a/b) + (c/d) = (a*d + b*c) / (b*d)
    public Fraction add(Fraction f2) {
        long newNumerator = this.top * f2.bottom + this.bottom * f2.top;
        long newDenom = this.bottom * f2.bottom;
        return new Fraction(newNumerator, newDenom);
    }
    
    // Override toString() to provide a string representation.
    // Always return "numerator/denominator" even if the denominator is 1.
    @Override
    public String toString() {
        return top + "/" + bottom;
    }
}
